#!/bin/sh

# El tamaño del disco zram a crear para montar en /tmp.
readonly TAM_ZRAM=1G

# Los controladores de cgroup v1 que estarán disponibles.
# lxc requiere que cada controlador tenga un directorio (jerarquía) independiente
# (all no funciona).
readonly CONTROLADORES_CGROUP='cpu,cpuacct,blkio,memory,devices,freezer,net_cls,net_prio,pids'
# El directorio raíz de todos los controladores (jerarquías) de cgroup v1, donde
# se montará un tmpfs.
readonly RAIZ_CGROUP='/sys/fs/cgroup'

readonly PATH='/bin:/sbin:/usr/sbin'

# Monta un tmpfs en /tmp, a modo de regresión si no se pudo
# montar un disco zram en ese directorio.
fallbackTmpfs() {
	printf 'ERROR (fallback tmpfs)\n'
	mount -t tmpfs -o mode=1777 tmpfs /tmp >/dev/null 2>&1
	exit
}

# Monta jerarquías de cgroups v1.
montarJerarquias() {
	IFS=','
	mount -t tmpfs -o size=64k cgroup_root /sys/fs/cgroup && for controlador in $CONTROLADORES_CGROUP; do
		mkdir -p "$RAIZ_CGROUP/$controlador" && mount -t cgroup -o $controlador cgroup "$RAIZ_CGROUP/$controlador"
		if [ $? != 0 ]; then
			break
		else
			# Establecer parámetros predeterminados para algunos controladores
			if [ "$controlador" = 'memory' ]; then
				echo 1 > "$RAIZ_CGROUP/$controlador/memory.use_hierarchy"
			fi

			# Añadir todos los procesos presentes hasta la fecha a un cgroup no raíz, para un mejor
			# control de sus límites de recursos: si están en el cgroup raíz, cada proceso se considera un cgroup
			# para controladores como cpu.share
			unset IFS
			IFS='
'			mkdir -p "$RAIZ_CGROUP/$controlador/system" && mkdir -p "$RAIZ_CGROUP/$controlador/lxc" && \
			for tarea in $(cat "$RAIZ_CGROUP/$controlador/tasks"); do
				echo $tarea >> "$RAIZ_CGROUP/$controlador/system/tasks" || true
			done && \
			if [ "$controlador" = 'cpu' ]; then
				# Usar solamente el 10% del tiempo total de CPU para los procesos del sistema
				# (1024 / 10 ~= 103). Otros cgroup (el cgroup lxc) tendrán derecho a repartirse
				# el 90% del tiempo de CPU
				echo 103 > "$RAIZ_CGROUP/$controlador/system/cpu.shares"
			fi
		fi
	done && \
	# También montamos una jerarquía sin controladores llamada "systemd", pues se espera su existencia
	# por parte de contenedores que utilicen systemd
	mkdir -p "$RAIZ_CGROUP/systemd" && mount -t cgroup -o none,name=systemd cgroup "$RAIZ_CGROUP/systemd"
}

# Monta el sistema de ficheros proc, si no fue montado
# ya en /proc.
montarProcSiNecesario() {
	if mountpoint /proc >/dev/null 2>&1; then
		# Ya se ha montado /proc
		:
	else
		mount -t proc proc /proc
	fi
}

# Necesitamos haber montado /proc para usar LVM
if montarProcSiNecesario; then
	# Escanear volúmenes lógicos disponibles
	printf 'Escaneando volúmenes lógicos disponibles: '
	vgchange -aay --sysinit && printf 'OK\n' || printf 'ERROR\n'
else
	printf 'No se pudo montar /proc. No se han escaneado los volúmenes lógicos disponibles.\n'
fi

# Montar sistemas de ficheros mencionados en fstab
printf 'Montando sistemas de ficheros configurados en /etc/fstab: '
mount -a && printf 'OK\n' || printf 'ERROR\n'

# A continuación, montar /tmp como disco zram
# (memoria comprimida)
if mountpoint -q '/tmp'; then
	# Ya se ha montado /tmp
	:
else
	printf 'Montando /tmp como disco zram: '

	# Establecer el tamaño del primer disco zram,
	# siempre creado por el núcleo (pues no es un módulo)
	printf '%s' "$TAM_ZRAM" > /sys/block/zram0/disksize

	mkfs.xfs -m crc=0 /dev/zram0 >/dev/null 2>&1 || fallbackTmpfs
	mount /dev/zram0 /tmp >/dev/null 2>&1 || fallbackTmpfs
	chmod 1777 /tmp >/dev/null 2>&1

	printf 'OK\n'
fi

# Finalmente, encargarse de los cgroups
printf 'Montando jerarquías de cgroups v1: '
montarJerarquias && printf 'OK\n' || printf 'ERROR\n'
