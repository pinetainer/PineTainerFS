From 95a83d7d7193bb5ce867ea940dfdafcb56dc8c11 Mon Sep 17 00:00:00 2001
From: AlexTMjugador <AlexTMjugador@users.noreply.github.com>
Date: Sun, 22 Sep 2019 15:45:41 +0200
Subject: [PATCH] Support filesystem creation options for block devices

This patch allows to specify filesystem specific creation options in
lxc-create, which will be used to initialize the filesystem in a
container block device storage (currently lvm, rbd and loop). These
options are passed as a field in the bdev_specs struct.

It also fixes the part of the documentation which states that only lvm
and loop block devices support the --fstype and --fssize options: rbd
also supports them, or so it seems.
---
 doc/lxc-create.sgml.in          |   4 +-
 src/lxc/lxccontainer.h          |   1 +
 src/lxc/storage/loop.c          |  14 +++--
 src/lxc/storage/lvm.c           |  10 +++-
 src/lxc/storage/rbd.c           |   7 ++-
 src/lxc/storage/storage_utils.c | 101 +++++++++++++++++++++++++++++++-
 src/lxc/tools/arguments.h       |   1 +
 src/lxc/tools/lxc_create.c      |  31 ++++++----
 8 files changed, 144 insertions(+), 25 deletions(-)

diff --git a/doc/lxc-create.sgml.in b/doc/lxc-create.sgml.in
index 1e97c40b1..fcad6fb0e 100644
--- a/doc/lxc-create.sgml.in
+++ b/doc/lxc-create.sgml.in
@@ -151,11 +151,13 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 	    default, <filename>lxc</filename>.
 	    <replaceable>--fstype FSTYPE</replaceable> will create an FSTYPE
 	    filesystem on the LV, rather than the default, which is ext4.
+	    <replaceable>--fsoptions OPTIONS</replaceable> will pass the filesystem
+	    specific creation OPTIONS to mkfs, rather than the defaults.
 	    <replaceable>--fssize SIZE</replaceable> will create a LV (and
 	    filesystem) of size SIZE rather than the default, which is 1G.
 	  </para>
 	  <para>
-	    If backingstore is 'loop', you can use <replaceable>--fstype FSTYPE</replaceable> and <replaceable>--fssize SIZE</replaceable> as 'lvm'. The default values for these options are the same as 'lvm'.
+	    If backingstore is 'loop' or 'rbd', you can use <replaceable>--fstype FSTYPE</replaceable>, <replaceable>--fsoptions OPTIONS</replaceable> and <replaceable>--fssize SIZE</replaceable> as 'lvm'. The default values for these options are the same as 'lvm'.
 	  </para>
 	  <para>
 	    If backingstore is 'rbd', then you will need to have a valid configuration in <filename>ceph.conf</filename> and a <filename>ceph.client.admin.keyring</filename> defined.
diff --git a/src/lxc/lxccontainer.h b/src/lxc/lxccontainer.h
index 208667d40..6b77eb003 100644
--- a/src/lxc/lxccontainer.h
+++ b/src/lxc/lxccontainer.h
@@ -894,6 +894,7 @@ struct lxc_snapshot {
 struct bdev_specs {
 	char *fstype; /*!< Filesystem type */
 	uint64_t fssize;  /*!< Filesystem size in bytes */
+	char *fsoptions; /*!< Filesystem specific creation options */
 	struct {
 		char *zfsroot; /*!< ZFS root path */
 	} zfs;
diff --git a/src/lxc/storage/loop.c b/src/lxc/storage/loop.c
index c685cc49e..65028bc2d 100644
--- a/src/lxc/storage/loop.c
+++ b/src/lxc/storage/loop.c
@@ -46,7 +46,7 @@
 
 lxc_log_define(loop, lxc);
 
-static int do_loop_create(const char *path, uint64_t size, const char *fstype);
+static int do_loop_create(const char *path, uint64_t size, const char *fstype, const char *fsoptions);
 
 /*
  * No idea what the original blockdev will be called, but the copy will be
@@ -123,7 +123,7 @@ int loop_clonepaths(struct lxc_storage *orig, struct lxc_storage *new,
 			size = DEFAULT_FS_SIZE;
 	}
 
-	ret = do_loop_create(srcdev, size, fstype);
+	ret = do_loop_create(srcdev, size, fstype, NULL);
 	if (ret < 0) {
 		ERROR("Failed to create loop storage volume \"%s\" with "
 		      "filesystem \"%s\" and size \"%" PRIu64 "\"",
@@ -138,7 +138,7 @@ int loop_create(struct lxc_storage *bdev, const char *dest, const char *n,
 		struct bdev_specs *specs)
 {
 	__do_free char *srcdev = NULL;
-	const char *fstype;
+	const char *fstype, *fsoptions;
 	uint64_t sz;
 	int ret, len;
 
@@ -183,6 +183,8 @@ int loop_create(struct lxc_storage *bdev, const char *dest, const char *n,
 	if (!fstype)
 		fstype = DEFAULT_FSTYPE;
 
+	fsoptions = specs->fsoptions;
+
 	bdev->dest = strdup(dest);
 	if (!bdev->dest) {
 		ERROR("Failed to duplicate string \"%s\"", dest);
@@ -196,7 +198,7 @@ int loop_create(struct lxc_storage *bdev, const char *dest, const char *n,
 	}
 
 
-	ret = do_loop_create(srcdev, sz, fstype);
+	ret = do_loop_create(srcdev, sz, fstype, fsoptions);
 	if (ret < 0) {
 		ERROR("Failed to create loop storage volume \"%s\" with "
 		      "filesystem \"%s\" and size \"%" PRIu64 "\"",
@@ -298,12 +300,12 @@ int loop_umount(struct lxc_storage *bdev)
 	return 0;
 }
 
-static int do_loop_create(const char *path, uint64_t size, const char *fstype)
+static int do_loop_create(const char *path, uint64_t size, const char *fstype, const char *fsoptions)
 {
 	int fd, ret;
 	off_t ret_size;
 	char cmd_output[PATH_MAX];
-	const char *cmd_args[2] = {fstype, path};
+	const char *cmd_args[3] = {fstype, fsoptions, path};
 
 	/* create the new loopback file */
 	fd = creat(path, S_IRUSR | S_IWUSR);
diff --git a/src/lxc/storage/lvm.c b/src/lxc/storage/lvm.c
index cc267b952..276d6a41f 100644
--- a/src/lxc/storage/lvm.c
+++ b/src/lxc/storage/lvm.c
@@ -557,7 +557,8 @@ bool lvm_create_clone(struct lxc_conf *conf, struct lxc_storage *orig,
 	}
 
 	cmd_args[0] = fstype;
-	cmd_args[1] = src;
+	cmd_args[1] = NULL;
+	cmd_args[2] = src;
 	ret = run_command(cmd_output, sizeof(cmd_output),
 			do_mkfs_exec_wrapper, (void *)cmd_args);
 	if (ret < 0) {
@@ -632,7 +633,7 @@ int lvm_destroy(struct lxc_storage *orig)
 int lvm_create(struct lxc_storage *bdev, const char *dest, const char *n,
 	       struct bdev_specs *specs)
 {
-	const char *vg, *thinpool, *fstype, *lv = n;
+	const char *vg, *thinpool, *fstype, *fsoptions, *lv = n;
 	uint64_t sz;
 	int ret, len;
 	const char *cmd_args[2];
@@ -682,8 +683,11 @@ int lvm_create(struct lxc_storage *bdev, const char *dest, const char *n,
 	if (!fstype)
 		fstype = DEFAULT_FSTYPE;
 
+	fsoptions = specs->fsoptions;
+
 	cmd_args[0] = fstype;
-	cmd_args[1] = lxc_storage_get_path(bdev->src, bdev->type);
+	cmd_args[1] = fsoptions;
+	cmd_args[2] = lxc_storage_get_path(bdev->src, bdev->type);
 	ret = run_command(cmd_output, sizeof(cmd_output), do_mkfs_exec_wrapper,
 			  (void *)cmd_args);
 	if (ret < 0) {
diff --git a/src/lxc/storage/rbd.c b/src/lxc/storage/rbd.c
index beeebab78..91c28dd95 100644
--- a/src/lxc/storage/rbd.c
+++ b/src/lxc/storage/rbd.c
@@ -100,7 +100,7 @@ int rbd_clonepaths(struct lxc_storage *orig, struct lxc_storage *new,
 int rbd_create(struct lxc_storage *bdev, const char *dest, const char *n,
 	       struct bdev_specs *specs)
 {
-	const char *rbdpool, *fstype;
+	const char *rbdpool, *fstype, *fsoptions;
 	uint64_t size;
 	int ret, len;
 	char sz[24];
@@ -168,8 +168,11 @@ int rbd_create(struct lxc_storage *bdev, const char *dest, const char *n,
 	if (!fstype)
 		fstype = DEFAULT_FSTYPE;
 
+	fsoptions = specs->fsoptions;
+
 	cmd_args[0] = fstype;
-	cmd_args[1] = lxc_storage_get_path(bdev->src, bdev->type);
+	cmd_args[1] = fsoptions;
+	cmd_args[2] = lxc_storage_get_path(bdev->src, bdev->type);
 	ret = run_command(cmd_output, sizeof(cmd_output), do_mkfs_exec_wrapper,
 			  (void *)cmd_args);
 	if (ret < 0) {
diff --git a/src/lxc/storage/storage_utils.c b/src/lxc/storage/storage_utils.c
index 319cd0461..ea554faae 100644
--- a/src/lxc/storage/storage_utils.c
+++ b/src/lxc/storage/storage_utils.c
@@ -48,6 +48,7 @@
 #include "parse.h"
 #include "storage.h"
 #include "storage_utils.h"
+#include "string_utils.h"
 #include "syscall_wrappers.h"
 #include "utils.h"
 
@@ -59,6 +60,8 @@
 #define BLKGETSIZE64 _IOR(0x12, 114, size_t)
 #endif
 
+static int add_mkfs_exec_wrapper_argument(char ***args, size_t *nargs, char *arg, size_t arglen);
+
 lxc_log_define(storage_utils, lxc);
 
 /*
@@ -236,11 +239,49 @@ int detect_fs(struct lxc_storage *bdev, char *type, int len)
 	_exit(EXIT_FAILURE);
 }
 
+static int add_mkfs_exec_wrapper_argument(char ***args, size_t *nargs, char *arg, size_t arglen)
+{
+	char **newargs = (char **)realloc(*args, ++*nargs * sizeof(char *));
+	char *b;
+
+	if (!newargs)
+		return -1;
+
+	/* Ignore the first quotation pair if present */
+	if (arglen > 1 && (arg[0] == '"' && arg[arglen - 1] == '"' || arg[0] == '\'' && arg[arglen - 1] == '\'')) {
+		arg++;
+		arglen -= 2;
+	}
+
+	/* arglen + \0 */
+	b = (char *)malloc(arglen + 1);
+	if (!b)
+		return -1;
+
+	/* Copy argument to buffer. Make sure it is null-terminated */
+	strncpy(b, arg, arglen);
+	b[arglen] = '\0';
+
+	newargs[*nargs - 1] = b;
+
+	*args = newargs;
+
+	return 0;
+}
+
 int do_mkfs_exec_wrapper(void *args)
 {
 	int ret;
+	size_t i;
 	char *mkfs;
 	char **data = args;
+
+	char quotedarg = 0;
+	char *argstart = data[1];
+	size_t arglen = 0;
+	size_t nargs = 0;
+	char **realargs = NULL;
+
 	/* strlen("mkfs.")
 	 * +
 	 * strlen(data[0])
@@ -259,10 +300,64 @@ int do_mkfs_exec_wrapper(void *args)
 		return -1;
 	}
 
-	TRACE("Executing \"%s %s\"", mkfs, data[1]);
-	execlp(mkfs, mkfs, data[1], (char *)NULL);
+	/* If we have fsoptions in data[1], use them. If not, ignore data[1] */
+	if (!data[1] || strlen(data[1]) == 0) {
+		TRACE("Executing \"%s %s\"", mkfs, data[2]);
+		execlp(mkfs, mkfs, data[2], (char *)NULL);
+
+		SYSERROR("Failed to run \"%s %s\"", mkfs, data[2]);
+	} else {
+		TRACE("Executing \"%s %s %s\"", mkfs, data[1], data[2]);
+
+		/* The first argument is the executable name */
+		if (add_mkfs_exec_wrapper_argument(&realargs, &nargs, mkfs, len - 1) < 0)
+			goto arg_fail;
+
+		/*
+		 * Parse filesystem options: consider each space as an argument
+		 * delimiter, unless we are inside a quoted string
+		 */
+		for (; *data[1]; data[1]++) {
+			if (*data[1] == '"' || *data[1] == '\'')
+				quotedarg = !quotedarg;
+
+			/*
+			 * End of argument reached because of a unescaped space.
+			 * Add it to the argument list
+			 */
+			if (*data[1] == ' ' && !quotedarg) {
+				if (add_mkfs_exec_wrapper_argument(&realargs, &nargs, argstart, arglen) < 0)
+					goto arg_fail;
+
+				argstart = data[1] + 1;
+				arglen = 0;
+			} else {
+				++arglen;
+			}
+		}
+
+		/* If needed, add the remaning argument after reaching end of string */
+		if (arglen)
+			if (add_mkfs_exec_wrapper_argument(&realargs, &nargs, argstart, arglen) < 0)
+				goto arg_fail;
+
+		/* Append the device path */
+		if (add_mkfs_exec_wrapper_argument(&realargs, &nargs, data[2], strlen(data[2])) < 0)
+			goto arg_fail;
+
+		execvp(mkfs, realargs);
+
+arg_fail:
+		SYSERROR("Failed to run \"%s %s %s\"", mkfs, data[1], data[2]);
+
+		/* Free allocated memory */
+		for (i = 0; i < nargs; i++)
+			free(realargs[i]);
+
+		if (realargs)
+			free(realargs);
+	}
 
-	SYSERROR("Failed to run \"%s %s\"", mkfs, data[1]);
 	free(mkfs);
 
 	return -1;
diff --git a/src/lxc/tools/arguments.h b/src/lxc/tools/arguments.h
index 9e8a27916..9618cfe4d 100644
--- a/src/lxc/tools/arguments.h
+++ b/src/lxc/tools/arguments.h
@@ -91,6 +91,7 @@ struct lxc_arguments {
 	char *bdevtype, *configfile, *template;
 	char *fstype;
 	uint64_t fssize;
+	char *fsoptions;
 	char *lvname, *vgname, *thinpool;
 	char *rbdname, *rbdpool;
 	char *zfsroot, *lowerdir, *dir;
diff --git a/src/lxc/tools/lxc_create.c b/src/lxc/tools/lxc_create.c
index 0309562c2..4dcefe64d 100644
--- a/src/lxc/tools/lxc_create.c
+++ b/src/lxc/tools/lxc_create.c
@@ -51,10 +51,11 @@ static const struct option my_longopts[] = {
 	{"thinpool", required_argument, 0, '2'},
 	{"fstype", required_argument, 0, '3'},
 	{"fssize", required_argument, 0, '4'},
-	{"zfsroot", required_argument, 0, '5'},
-	{"dir", required_argument, 0, '6'},
-	{"rbdname", required_argument, 0, '7'},
-	{"rbdpool", required_argument, 0, '8'},
+	{"fsoptions", required_argument, 0, '5'},
+	{"zfsroot", required_argument, 0, '6'},
+	{"dir", required_argument, 0, '7'},
+	{"rbdname", required_argument, 0, '8'},
+	{"rbdpool", required_argument, 0, '9'},
 	LXC_COMMON_OPTIONS
 };
 
@@ -91,12 +92,16 @@ Options :\n\
       --zfsroot=PATH            Create zfs under given zfsroot\n\
                                 (Default: tank/lxc)\n\
 \n\
-  BDEV options for LVM or Loop (with -B/--bdev lvm/loop) :\n\
+  BDEV options for LVM, RBD or Loop (with -B/--bdev lvm/rbd/loop) :\n\
       --fstype=TYPE             Create fstype TYPE\n\
                                 (Default: ext4)\n\
       --fssize=SIZE[U]          Create filesystem of\n\
                                 size SIZE * unit U (bBkKmMgGtT)\n\
                                 (Default: 1G, default unit: M)\n\
+      --fsoptions=OPTIONS       Filesystem specific\n\
+                                creation options\n\
+                                (Default: none)\n\
+\n\
   -- template-options\n\
          This will pass template-options to the template as arguments.\n\
          To see the list of options supported by the template,\n\
@@ -136,15 +141,18 @@ static int my_parser(struct lxc_arguments *args, int c, char *arg)
 		args->fssize = get_fssize(arg);
 		break;
 	case '5':
-		args->zfsroot = arg;
+		args->fsoptions = arg;
 		break;
 	case '6':
-		args->dir = arg;
+		args->zfsroot = arg;
 		break;
 	case '7':
-		args->rbdname = arg;
+		args->dir = arg;
 		break;
 	case '8':
+		args->rbdname = arg;
+		break;
+	case '9':
 		args->rbdpool = arg;
 		break;
 	}
@@ -179,11 +187,11 @@ static void create_helpfn(const struct lxc_arguments *args)
 static bool validate_bdev_args(struct lxc_arguments *args)
 {
 	if (strncmp(args->bdevtype, "best", strlen(args->bdevtype)) != 0) {
-		if (args->fstype || args->fssize)
+		if (args->fstype || args->fssize || args->fsoptions)
 			if (strncmp(args->bdevtype, "lvm", strlen(args->bdevtype)) != 0 &&
 			    strncmp(args->bdevtype, "loop", strlen(args->bdevtype)) != 0 &&
 			    strncmp(args->bdevtype, "rbd", strlen(args->bdevtype)) != 0) {
-				ERROR("Filesystem type and size are only valid with block devices");
+				ERROR("Filesystem type, size and options are only valid with block devices");
 				return false;
 			}
 
@@ -297,6 +305,9 @@ int main(int argc, char *argv[])
 	if (my_args.fssize)
 		spec.fssize = my_args.fssize;
 
+	if (my_args.fsoptions)
+		spec.fsoptions = my_args.fsoptions;
+
 	if ((strncmp(my_args.bdevtype, "zfs", strlen(my_args.bdevtype)) == 0) ||
 	    (strncmp(my_args.bdevtype, "best", strlen(my_args.bdevtype)) == 0))
 		if (my_args.zfsroot)
-- 
2.20.1

