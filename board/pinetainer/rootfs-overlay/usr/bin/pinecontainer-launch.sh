#!/bin/sh

# Launches a Pinecontainer virtual machine.
# Parameters:
# -v lvm_volume_group_name: the name of the LVM volume group where Pinecontainers logical volumes will reside.
# -d runtime_data_dir: the runtime data directory, where runtime data about VMs will be stored.
# $1: Pinecontainer settings file (contains which template script to run and its environment variables)

# ########################################## #
# Setting and template files quick reference #
# ########################################## #
# The setting files follow a line-delimited text format, key=value.
# Lines that start with '#' are comments.
#
# Key regex: [A-Z0-9_]+
# Values can be any text that this shell script reads nicely.
#
# All keys and values are passed through to the template script (maybe processed; see special keys below).
#
# Required keys:
# TEMPLATE_SCRIPT PINECONTAINER_NAME MAIN_MEMORY_SIZE
# MAIN_DISK_SIZE MINIMUM_CPU_ALLOCATION_PERCENT MINIMUM_IOPS_ALLOCATION_PERCENT
#
# Forbidden keys (can't be used in settings file):
# LVM_VOLUME_GROUP_NAME RUNTIME_DATA_DIR TEMPLATE_DIR
# MAIN_BLOCK_DEVICE NVRAM_BLOCK_DEVICE CONTROL_SOCKET_DIR
#
# Special keys (are used or processed by this script somehow, and not just passed through to the template script):
# MAIN_MEMORY_SIZE MINIMUM_CPU_ALLOCATION_PERCENT MINIMUM_IOPS_ALLOCATION_PERCENT
# VIRTUAL_INTERFACE_MAC MAIN_VOLUME_IMAGE NEEDS_NVRAM_VOLUME
# NVRAM_VOLUME_IMAGE HOST_UID TEMPLATE_SCRIPT
#
# Keys generated by this script that are available to template scripts:
# MAIN_BLOCK_DEVICE
# NVRAM_BLOCK_DEVICE (only if NEEDS_NVRAM_VOLUME is set in the settings)
# CONTROL_SOCKET_DIR
#
# Template scripts must replace their own process with a VM process, and expose a Unix socket
# monitor interface at $CONTROL_SOCKET_DIR/monitor.sock that accepts the
# 'system_powerdown' command to initiate an orderly shutdown.

# The init.d script that sets up the cgroup hierarchy
readonly CGROUPS_INITD_SCRIPT=/etc/init.d/S00cgroups.sh

# The folder where VM template scripts are stored
readonly TEMPLATE_DIR=/var/lib/pinecontainer/templates

# The user group that will be assigned to VMs
readonly VM_HOST_GROUP=pinecontainer

# Import environment variables from the cgroup init.d script
# shellcheck source=../../etc/init.d/S00cgroups.sh
. "$CGROUPS_INITD_SCRIPT"

# Returns success if the provided parameter, which is expected to contain a 0-100 percentage value,
# actually contains a value that fullfills that expectation.
is_sane_percentage() {
	{ [ "$1" -gt 0 ] && [ "$1" -le 100 ]; } 2>/dev/null
}

# Generates a very-likely-unique MAC address from a Pinecontainer name.
# The generated MAC address is the result of a one way function whose
# parameter is the VM name.
# $1: the name of the container.
generate_mac() {
	# Do a cheap hash (IEEE 802.3 Ethernet CRC32) on the name
	name_crc=$(echo "$1" | cksum)
	name_crc=${name_crc%% *}

	# Fake two more result bytes by doing ones' complement on the
	# resulting hash
	name_crc_extra=$((name_crc ^ 0x0000FFFF))
	name_crc_extra=$((name_crc_extra & 0x0000FFFF))

	# The first two bytes of the MAC address come from the extra
	# bytes. Just make sure that it is a unicast, locally administered
	# MAC (bits xxxxxx10 on the first byte)
	first_two_mac_bytes=$((name_crc_extra & 0xFCFF))
	first_two_mac_bytes=$((first_two_mac_bytes | 0x0200))

	# Finally, combine both byte sources to get the MAC
	printf '%04x%08x' $first_two_mac_bytes "$name_crc" | sed -E '1{s/([0-9a-f][0-9a-f])/&:/g;s/:$//}'
}

# Creates a LVM logical volume.
# $1: the name of the LV.
# $2: the size of the LV, in any format accepted by lvcreate --size option.
# $3: the volume group where the LV will be created.
# Returns the status code of lvcreate, printing output to the standard error stream
# only if an error occurs.
create_lv() {
	if ! lvcreate --yes -n "$1" -L "$2" "$3" >/dev/null 2>&1; then
		status_code=$?
		echo "$0: an error occurred while creating LV $1 of size $2. Code: $status_code" >&2
		return $status_code
	else
		echo "$0: created logical volume $1 in volume group $3"
	fi
}

# Initializes a LVM logical volume for a VM via a raw data file or program.
# $1: the name of the LV.
# $2: the volume group where the LV resides.
# $3: the raw data file or program to use to initialize the block device data.
# If it is a program, it will receive as arguments $1 and $2, in that order,
# and its standard output will be copied to the LV.
# Returns a success status code if and only if the initialization went fine.
# In other case, a error status code is returned. Text may be printed to both
# standard output and standard error streams.
initialize_lv() {
	if [ -x "$3" ]; then
		echo "$0: initializing logical volume $1 with $3 output"
		"$3" "$1" "$2" | dd of="/dev/mapper/$2-$1" bs=4M status=progress
	else
		echo "$0: initializing logical volume $1 with data from $3"
		dd if="$2" of="/dev/mapper/$2-$1" bs=4M status=progress
	fi
}

while getopts v:d: option; do
	case $option in
		v)		LVM_VOLUME_GROUP_NAME="$OPTARG";;
		d)		RUNTIME_DATA_DIR="$OPTARG";;
		?|*)	printf "Syntax: %s -v lvm_volume_group_name -d runtime_data_dir pinecontainer_settings_file\n" "$0" >&2
				exit 1;;
	esac
done

shift $((OPTIND - 1)) 2>/dev/null
if [ ! -f "$1" ] || [ ! -r "$1" ]; then
	echo "$0: unexisting or unreadable settings file: $2" >&2
	exit 2
fi

if ! "$CGROUPS_INITD_SCRIPT" status 2>/dev/null; then
	echo "$0: cgroup hierarchy not set up. Please run '$CGROUPS_INITD_SCRIPT' start" >&2
	exit 3
fi

if [ -z "$LVM_VOLUME_GROUP_NAME" ]; then
	echo "$0: the LVM volume group name was empty or unset" >&2
	exit 4
fi

if [ -z "$RUNTIME_DATA_DIR" ]; then
	echo "$0: the rubntime data directory was empty or unset" >&2
	exit 5
fi

while read -r line; do
	case $line in
		'#'*)	# Ignore comments
				continue;;

		*=*)	# Substitute or interpret template setting variables
				trimmed_line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*=[[:space:]]*/=/;s/[[:space:]]*$//')"
				variable_name="${trimmed_line%%=*}"
				variable_value="${trimmed_line##*=}"

				case $variable_name in
					MAIN_MEMORY_SIZE)
						# Passthrough the setting, but also store it for cgroup configuration, and make
						# sure it is expressed in bytes or mebibytes
						variable_value_no_suffix="${variable_value%M}"
						if [ "$variable_value_no_suffix" -eq "$variable_value_no_suffix" ] 2>/dev/null; then
							if [ ${#variable_value} -eq ${#variable_value_no_suffix} ]; then
								# No suffix, so the size was already in bytes
								main_memory_size_bytes="$variable_value"
							else
								# The size was in mebibytes; convert that to bytes
								main_memory_size_bytes="$((variable_value_no_suffix * 1048576))"
							fi

							export MAIN_MEMORY_SIZE="$variable_value"
						fi;;
					MINIMUM_CPU_ALLOCATION_PERCENT)
						# Minimum number of CPU shares that CFS will assign to the VM under contention.
						# Note that the sum of percentages across VMs and the system should be 100%, for
						# every kind of resource, but we can't check that here
						is_sane_percentage "$variable_value" && \
						export MINIMUM_CPU_ALLOCATION_PERCENT=$(((TOTAL_CPU_SHARES * variable_value) / 100));;
					MINIMUM_IOPS_ALLOCATION_PERCENT)
						# Minimum throughput and time of secondary memory devices that BFQ will assign
						# to the VM under contention
						is_sane_percentage "$variable_value" && \
						export MINIMUM_IOPS_ALLOCATION_PERCENT=$(((TOTAL_IOPS_SHARES * variable_value) / 100));;
					VIRTUAL_INTERFACE_MAC)
						# Save the value if it is a MAC
						if echo "$variable_value" | grep -Eqx '([0-9A-Fa-f]{2}:){5}[0-9A-Fa-f]{2}'; then
							export VIRTUAL_INTERFACE_MAC="$variable_value"
						fi;;
					*)	# Generic template environment variable
						# Skip forbidden variable names
						for forbidden_name in LVM_VOLUME_GROUP_NAME RUNTIME_DATA_DIR TEMPLATE_DIR MAIN_BLOCK_DEVICE NVRAM_BLOCK_DEVICE CONTROL_SOCKET_DIR; do
							if [ "$variable_name" = "$forbidden_name" ]; then
								continue
							fi
						done
						eval "export $variable_name='$variable_value'"
				esac;;

		*) 		# Ignore everything else
				continue;;
	esac
done < "$2"

# Make sure that the required settings were provided
for required_variable in TEMPLATE_SCRIPT PINECONTAINER_NAME MAIN_MEMORY_SIZE MAIN_DISK_SIZE MINIMUM_CPU_ALLOCATION_PERCENT MINIMUM_IOPS_ALLOCATION_PERCENT; do
	if [ -z "$(eval printf '%s' "\$$required_variable")" ]; then
		echo "$0: required variable $required_variable is missing from the settings file $2, or is invalid. Refusing to launch the VM" >&2
		exit 10
	fi
done

# Create logical volumes for this VM if they don't exist yet
if ! lvs --readonly --logonly -q "$LVM_VOLUME_GROUP_NAME/$PINECONTAINER_NAME" >/dev/null 2>&1; then
	NVRAM_VOLUME_IMAGE="${NVRAM_VOLUME_IMAGE:-/dev/null}"
	MAIN_VOLUME_IMAGE="${MAIN_VOLUME_IMAGE:-/dev/null}"

	if ! create_lv "$PINECONTAINER_NAME" "$MAIN_DISK_SIZE" "$LVM_VOLUME_GROUP_NAME" && \
	initialize_lv "$PINECONTAINER_NAME" "$LVM_VOLUME_GROUP_NAME" "$MAIN_VOLUME_IMAGE" && \
	if [ -n "$NEEDS_NVRAM_VOLUME" ]; then
		create_lv "${PINECONTAINER_NAME}_nvram" 64M "$LVM_VOLUME_GROUP_NAME" && \
		initialize_lv "${PINECONTAINER_NAME}_nvram" "$LVM_VOLUME_GROUP_NAME" "$NVRAM_VOLUME_IMAGE"
	fi
	then
		echo "$0: an error occurred while initializing the logical volume storage for $PINECONTAINER_NAME" >&2
		exit 11
	fi
fi

# Set environment variables for the block devices
export MAIN_BLOCK_DEVICE="/dev/mapper/$LVM_VOLUME_GROUP_NAME-$PINECONTAINER_NAME"
if [ -n "$NEEDS_NVRAM_VOLUME" ]; then
	export NVRAM_BLOCK_DEVICE="/dev/mapper/$LVM_VOLUME_GROUP_NAME-${PINECONTAINER_NAME}_nvram"
fi

# Set block device permissions accordingly
for block_device in $MAIN_BLOCK_DEVICE $NVRAM_BLOCK_DEVICE; do
	{ chmod 600 "$block_device" && chown "$HOST_UID:$VM_HOST_GROUP" "$block_device"; } >/dev/null 2>&1
done

# Generate a MAC if we don't have one
if [ -z "$VIRTUAL_INTERFACE_MAC" ]; then
	generated_mac="$(generate_mac "$PINECONTAINER_NAME")"
	echo "$0: generated MAC for the $PINECONTAINER_NAME NIC: $generated_mac"
	export VIRTUAL_INTERFACE_MAC="$generated_mac"
fi

# Create the cgroup for the VM
if ! mkdir "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME"; then
	echo "$0: couldn't create a cgroup for $PINECONTAINER_NAME. Refusing to launch the VM" >&2
	exit 12
fi

# The directory where VM control sockets shall be created
export CONTROL_SOCKET_DIR="$RUNTIME_DATA_DIR/$PINECONTAINER_NAME"

# Create the directories for runtime data
if ! mkdir -p "$CONTROL_SOCKET_DIR" 2>/dev/null; then
	echo "$0: couldn't create the directory for the VM runtime data: $CONTROL_SOCKET_DIR" >&2
	rmdir "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME" 2>/dev/null
	exit 13
fi

if
# Guarantee $main_memory_size_bytes bytes of memory to the cgroup
echo $main_memory_size_bytes > "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME/memory.low" && \
# Allow up to $main_memory_size_bytes + 16 MiB of memory usage by the cgroup, to account for
# memory used by the hypervisor and the kernel (due to requests by the hypervisor)
echo $((main_memory_size_bytes + 16777216)) > "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME/memory.high" && \
# Kill the VM if its memory usage is greater than $main_memory_size_bytes + 32 MiB
echo $((main_memory_size_bytes + 33554432)) > "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME/memory.max" && \
# Do not allow too many processes in the cgroup. QEMU spawns a process and VCPUS threads,
# which for practical purposes will amount to at most 5 PIDs. The rest 5 PIDs are provided
# for administration purposes
echo 10 > "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME/pids.max" && \
# CPU and IOPS allocation percentages
echo $MINIMUM_CPU_ALLOCATION_PERCENT > "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME/cpu.weight" && \
echo $MINIMUM_IOPS_ALLOCATION_PERCENT > "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME/io.bfq.weight" && \

# Now launch QEMU, and put it in its cgroup by temporarily changing out cgroup.
# We unshare the PID, UTS, IPC and mount namespaces because it is easy and
# provides more isolation, although dropping privileges should be enough
current_cgroup="$(head -n1 /proc/self/cgroup 2>/dev/null)" && \
current_cgroup="${current_cgroup:-0::$CGROUP_HIERARCHY_MOUNTPOINT/system}" && \
current_cgroup="${current_cgroup#0::}" && \

echo $$ > "$CGROUP_HIERARCHY_MOUNTPOINT/$PINECONTAINER_NAME/cgroup.procs"
then
	unshare -f -p --mount-proc -u -i --kill-child \
	"$TEMPLATE_DIR/$TEMPLATE_SCRIPT" -name "$PINECONTAINER_NAME,process=$PINECONTAINER_NAME" -runas "$HOST_UID:$VM_HOST_GROUP" &
	echo $$ > "$current_cgroup/cgroup.procs"
else
	echo "$0: an error ocurred while configuring the cgroup for the VM. Code: $?" >&2
	exit 14
fi
